#include <stdio.h>

int num, count = 0, sum = 0, record[30], top = -1;  // top用于记录当前排列最后一位的位置

void dfs(int now)
{
	if(sum == num) { // 当前排列总和等于 num 输出整个排列
		printf("%d=", num);
		for(int i = 0; i < top; i++)
			printf("%d+", record[i]);
		count++;		// 记录输出了几次，控制输出
		if(count % 4 == 0 || record[top] == num)
			printf("%d\n", record[top]);
		else
			printf("%d;", record[top]);
	}
	else if(sum < num)		// 当前排列总和小于 num，继续进行排列
		for(int i = now; i <= num; i++) { // 从 1开始依次枚举排列
			record[++top] = i;	// top位置+1 将当前可能的排列数赋值给它
			sum += i;			// 总和 加上当前可能的排列数
			dfs(i);				// 继续进行下一位排列数的枚举
			sum -= i;			// 递归返回，sum，top返回为进行递归前的数值
			top--;
		}
}
int main()
{
	scanf("%d", &num);
	dfs(1);		// 从 1开始枚举整个排列 
	return 0;
}

/*
本体涉及到递归的灵活运用，有一定难度。
关于递归地题目在于寻找规律，找到递归的方式；
例：对于 5 的排列枚举结果：
5=1+1+1+1+1;5=1+1+1+2;5=1+1+3;5=1+2+2
5=1+4;5=2+3;5=5
在此进行剖解分析：

程序中 dfs 执行第一次，参数为 1，从 1开始，向下枚举可能的排列
比如上式以 5为例的排列中，从一开始，则下一次执行 dfs 也是从一开始，
直到 1+1+1+1+1=5，为止，输出排列，最后一层递归返回，即把最后一位删除，
枚举观察1向上有无合适的数：意为 1+1+1+1+X 寻找合适的比 1大的 X使得
当前排列和为 5，1 向上为 2，显然 2 不满足条件，下一层递归返回，此时排
列为 1+1+1+X 从 1 向上寻找合适的 X使得排列和为 5，得到 X = 2，即 1+1+1+2 
条件满足输出当前排列，此时下一层递归返回，排列为 1+1+X，从 1向上寻找
合适的 X使得排列和为 5.递归得 X = 2，此时1+1+2=4，和小于5，继续递归一次，
得 1+1+2+2 大于 5，递归返回，继续由 2开始向上递归，得 1+1+3
排列和等于 5 条件符合，输出当前排列，下一层递归返回，此时排列为 1+X
从 1向上枚举排列，得 1+2 和小于 5，继续递归，得 1+2+2，等于 5
输出当前排列，下层递归返回，此时排列为1+X，X由 2向上枚举，得1+3
小于 5，继续递归枚举，得 1+3+3 大于 5 递归返回，继续由 3向上递归枚举，
得 1+4 和为 5，满足条件，输出当前排列，下层递归返回，此时排列为 X，
由 1 向上递归枚举排列，得 2，小于 5，继续递归，得 2+2，小于 5，继续递归枚举，
得 2+2+2，大于 5 ，递归返回，由2向上枚举，得 2+3 和为 5，满足条件，输出当前排列，
下层递归返回，此时排列依然为 X ，由2 向上枚举得 3，小于5，继续递归得 3+3
大于 5， 递归返回，此时排列为 X，继续由 3 向上枚举得 4，继续递归得 4+4
大于 5， 递归返回，由 4向上枚举，得 5 条件满足，输出当前排列，下层递归返回，此时
第一次 dfs 函数调用循环退出，函数结束，返回主程序，程序结束

以上详细描述了程序的执行过程，递归的具体实现
*/